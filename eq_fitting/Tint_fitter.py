import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# ----------------------------------
# data
# ----------------------------------
raw_data = """
0	330	66
10	330	66
20	330	67
30	330	67
40	330	67
50	330	67
60	330	69
70	330	70
80	330	70
90	330	72
100	330	72
110	330	74
120	330	79
130	330	79
140	330	75
150	330	80
160	330	82
170	330	83
180	330	85
190	330	88
200	330	90
210	330	93
220	330	95
230	330	95
240	330	98
250	330	100
260	330	100
270	330	103
280	330	105
290	330	105
300	330	106
310	330	110
320	330	116
330	330	119
340	330	121
350	330	123
360	330	124
370	330	126
380	330	127
390	330	129
400	330	131
410	330	134
420	330	137
430	330	139
440	330	140
450	330	142
460	330	144
470	330	145
480	330	147
490	330	149
500	330	150
510	330	152
520	330	154
530	330	155
540	330	155
0	290	66
10	290	67
20	290	66
30	290	69
40	290	68
50	290	70
60	290	72
70	290	74
80	290	75
90	290	77
100	290	79
110	290	80
120	290	82
130	290	84
140	290	87
150	290	89
160	290	91
170	290	92
180	290	93
190	290	94
200	290	95
210	290	95
220	290	97
230	290	98
240	290	99
250	290	100
260	290	102
270	290	103
280	290	105
290	290	106
300	290	108
310	290	109
320	290	110
330	290	111
340	290	112
350	290	114
360	290	114
370	290	115
380	290	116
390	290	116
400	290	117
410	290	118
420	290	120
430	290	122
440	290	123
450	290	125
460	290	126
470	290	126
480	290	128
490	290	130
500	290	132
510	290	133
520	290	133
530	290	135
540	290	136
550	290	137
560	290	139
570	290	141
580	290	143
590	290	143
600	290	146
610	290	147
620	290	148
630	290	149
640	290	150
650	290	151
660	290	152
670	290	152
680	290	153
690	290	153
700	290	154
710	290	154
720	290	154
730	290	155
740	290	155
750	290	157
760	290	157
770	290	158
780	290	158
790	290	159
800	290	160
810	290	160
820	290	161
830	290	161
840	290	161
850	290	162
860	290	162
870	290	163
880	290	163
890	290	163
900	290	165
0	325	66
10	325	66
20	325	65
30	325	66
40	325	66
50	325	67
60	325	68
70	325	67
80	325	69
90	325	69
100	325	71
110	325	73
120	325	74
130	325	75
140	325	77
150	325	80
160	325	82
170	325	83
180	325	86
190	325	87
200	325	89
210	325	92
220	325	96
230	325	97
240	325	99
250	325	101
260	325	102
270	325	105
280	325	107
290	325	109
300	325	111
310	325	113
320	325	115
330	325	117
340	325	120
350	325	121
360	325	124
370	325	126
380	325	128
390	325	129
400	325	130
410	325	132
420	325	133
430	325	135
440	325	136
450	325	137
460	325	138
470	325	139
480	325	141
490	325	142
500	325	144
510	325	146
520	325	147
530	325	148
540	325	150
550	325	151
560	325	153
570	325	155
0	390	66
10	390	67
20	390	68
30	390	67
40	390	67
50	390	69
60	390	69
70	390	69
80	390	70
90	390	72
100	390	73
110	390	73
120	390	74
130	390	76
140	390	78
150	390	80
160	390	81
170	390	83
180	390	85
190	390	85
200	390	88
210	390	94
220	390	95
230	390	97
240	390	98
250	390	99
260	390	101
270	390	105
280	390	106
290	390	108
300	390	111
310	390	113
320	390	115
330	390	118
340	390	119
350	390	121
360	390	124
370	390	127
380	390	130
390	390	133
400	390	134
410	390	137
420	390	139
430	390	142
440	390	144
450	390	147
"""

# parse data
data = np.array([list(map(float, L.split())) for L in raw_data.strip().splitlines()])
time       = data[:,0]
pan_temp   = data[:,1]
T_internal = data[:,2]
T0 = T_internal[0]

# ----------------------------------
#  identify steaks and assign weights (weight each steak equally)
# ----------------------------------
steak_ids = np.cumsum(time == 0)

unique_ids, counts = np.unique(steak_ids, return_counts=True)
point_weights = np.zeros_like(steak_ids, dtype=float)

for uid, count in zip(unique_ids, counts):
    point_weights[steak_ids == uid] = 1.0 / count

# normalize
point_weights *= len(data) / len(unique_ids)

# ----------------------------------
# T(t,p) = T0 + (p - T0) / [1 + exp(- (a + d*p) * (t - b) )]
# c = c
# b = g
# a = d
# d = f
# ----------------------------------
def model(inputs, a, d, b, c):
    t, p = inputs
    slope = a + d * (p - T0)
    const = - (p - T0) / (1 + np.exp(slope * (c * b)))
    return T0 + (p - T0) / (1 + np.exp(-slope * c * (t - b))) + const

# ----------------------------------
# fit with weights
# ----------------------------------
initial_guess = [1e-3, 1e-5, 100, 0]
popt, pcov = curve_fit(
    model,
    (time, pan_temp),
    T_internal,
    p0=initial_guess,
    sigma=1.0 / point_weights,  # larger weight → smaller sigma
    absolute_sigma=False,
    maxfev=200000
)
a_fit, d_fit, b_fit, c_fit = popt
print(f"a = {a_fit:.3e},  d = {d_fit:.3e},  b = {b_fit:.1f}, c = {c_fit:.1f}")

# ----------------------------------
# plotting
# ----------------------------------
t_vals = np.linspace(time.min(), time.max(), 100)
p_vals = np.linspace(pan_temp.min(), pan_temp.max(), 100)
tt, pp = np.meshgrid(t_vals, p_vals)
zz = model((tt, pp), *popt)

fig = plt.figure(figsize=(10, 7))
ax = fig.add_subplot(projection='3d')
ax.plot_surface(tt, pp, zz, cmap='viridis', alpha=0.7, edgecolor='none')
ax.scatter(time, pan_temp, T_internal, color='red', s=10, label='Data')
ax.set_xlabel("Time (s)")
ax.set_ylabel("Pan Temp (°C)")
ax.set_zlabel("Internal Temp (°C)")
ax.set_title("Weighted Fit (Equal Steak Influence)")
ax.legend()
plt.tight_layout()
plt.show()